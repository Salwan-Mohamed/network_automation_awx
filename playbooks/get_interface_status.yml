---
# Play 1: Resolve the switch from the room and prepare target interface(s)
- name: Resolve switch from room and prepare targets
  hosts: localhost
  gather_facts: false

  tasks:
    ##########################################################################
    # Load mappings (with fallbacks so they always load)
    ##########################################################################
    - name: Load switch_mapping (vars/switch_mapping.yml)
      include_vars:
        file: vars/switch_mapping.yml
      register: _sw1
      failed_when: false
      ignore_errors: true
      when: switch_mapping is not defined

    - name: Load switch_mapping (../vars/switch_mapping.yml)
      include_vars:
        file: ../vars/switch_mapping.yml
      register: _sw2
      failed_when: false
      ignore_errors: true
      when: switch_mapping is not defined

    - name: Load switch_mapping (switch_mapping.yml at cwd)
      include_vars:
        file: switch_mapping.yml
      register: _sw3
      failed_when: false
      ignore_errors: true
      when: switch_mapping is not defined

    - name: Fail if switch_mapping not loaded
      fail:
        msg: "Could not load 'switch_mapping'. Ensure it defines 'switch_mapping: { switch: [rooms...] }'."
      when: switch_mapping is not defined

    # Wall-point mapping is optional; we try to load it from common locations
    - name: Load wall_point_mapping (optional, vars/wall_point_mapping.yml)
      include_vars:
        file: vars/wall_point_mapping.yml
      register: _wpm1
      failed_when: false
      ignore_errors: true

    - name: Load wall_point_mapping (optional, ../vars/wall_point_mapping.yml)
      include_vars:
        file: ../vars/wall_point_mapping.yml
      register: _wpm2
      failed_when: false
      ignore_errors: true
      when: wall_point_mapping is not defined

    - name: Load wall_point_mapping (optional, wall_point_mapping.yml at cwd)
      include_vars:
        file: wall_point_mapping.yml
      register: _wpm3
      failed_when: false
      ignore_errors: true
      when: wall_point_mapping is not defined

    ##########################################################################
    # Normalize the incoming interface variable to a usable port id
    # Accept: port_number (preferred), port, interface, ifname
    ##########################################################################
    - name: Determine raw port token from survey
      set_fact:
        _raw_port_token: >-
          {{
            [ port_number | default(''),
              port | default(''),
              interface | default(''),
              ifname | default('') ]
            | map('string') | map('trim') | reject('equalto','') | list | first | default('')
          }}

    - name: Ensure we got a room and a port token
      assert:
        that:
          - room is defined
          - (room | string) | length > 0
          - (_raw_port_token | string) | length > 0
        fail_msg: "Provide 'room' and a port (one of: port_number, port, interface, ifname). Example: room: n-g-36, port_number: '1/20'."

    # Apply wall-point mapping if present
    - name: Apply wall-point mapping if available
      set_fact:
        _mapped_port_token: "{{ wall_point_mapping[_raw_port_token] }}"
      when:
        - wall_point_mapping is defined
        - _raw_port_token in wall_point_mapping

    # Heuristic normalization:
    # - replace '-' or '_' with '/'
    # - if still no '/', and token is digits only with length>=2:
    #   assume first digit = stack/member, rest = port number (int)
    #   e.g. '120' -> '1/20', '402' -> '4/2'
    - name: Normalize port token to Aruba interface format
      vars:
        tok: "{{ _mapped_port_token | default(_raw_port_token) | trim }}"
      set_fact:
        port_number_effective: >-
          {% set t = tok | regex_replace('\\s+', '') %}
          {% set t = t | regex_replace('[-_]', '/') %}
          {% if '/' in t %}
            {{ t }}
          {% elif t is match('^\\d{2,}$') %}
            {{ (t[0]) ~ '/' ~ ((t[1:] | int) | string) }}
          {% else %}
            {{ t }}
          {% endif %}

    - name: Locate switch for given room (case-insensitive)
      set_fact:
        switch_name: "{{ item.key }}"
      loop: "{{ switch_mapping | dict2items }}"
      when: (room | lower) in (item.value | map('lower') | list)

    - name: Fail if no switch matches the room
      fail:
        msg: "Room '{{ room }}' not found in switch_mapping."
      when: switch_name is not defined

    - name: Build target interface list
      set_fact:
        target_interfaces: ["{{ port_number_effective }}"]

    - name: Add resolved switch as a host for Play 2
      add_host:
        name: "{{ switch_name }}"
        groups: target_switch
        target_interfaces: "{{ target_interfaces }}"

# Play 2: Connect to the switch and fetch interface info
- name: Fetch interface status / enabled / name (ArubaOS-Switch)
  hosts: target_switch
  gather_facts: false
  connection: network_cli
  vars:
    ansible_network_os: community.network.aruba
  collections:
    - community.network

  tasks:
    - name: Initialize result list
      set_fact:
        interfaces_info: []

    # Run BOTH show commands per interface
    - name: Collect show outputs per interface
      community.network.aruba_command:
        commands:
          - "show interface {{ item }}"
          - "show running-config interface {{ item }}"
      loop: "{{ target_interfaces }}"
      register: show_outputs

    # Parse robustly; if the command output indicates invalid port, mark it so.
    - name: Parse and accumulate results
      vars:
        si_text: "{{ (res.stdout[0] | default('')) | regex_replace('\\r','') }}"
        sr_text: "{{ (res.stdout[1] | default('')) | regex_replace('\\r','') }}"
        si_lower: "{{ si_text | lower }}"
        invalid: >-
          {{ 'invalid port' in si_lower or 'module not present' in si_lower }}
      set_fact:
        interfaces_info: >-
          {{
            interfaces_info + [ {
              'interface': res.item,
              'link_status': (
                 ( 'Invalid' if invalid else
                   ( (si_lower | regex_findall('link\\s+status\\s*:\\s*([a-z]+)') | first | default('unknown')) | capitalize )
                 )
              ),
              'port_enabled': (
                 ( 'Unknown' if invalid else
                   ( (si_lower | regex_findall('port\\s+enabled\\s*:\\s*([a-z]+)') | first | default('unknown')) | capitalize )
                 )
              ),
              'name': (
                 ( sr_text | regex_findall('name\\s+\\"\\s*(.*?)\\s*\\"') | first | default('') | trim )
                 | default( (si_text | regex_findall('Name\\s*:\\s*(.+)') | first | default('')) )
                 | trim
              )
            } ]
          }}
      loop: "{{ show_outputs.results }}"
      loop_control:
        loop_var: res
        label: "{{ res.item }}"

    - name: Summary (per interface)
      debug:
        msg: >-
          Interface {{ item.interface }} |
          Link Status: {{ item.link_status }} |
          Port Enabled: {{ item.port_enabled }} |
          Name: {{ item.name }}
      loop: "{{ interfaces_info }}"
      loop_control:
        label: "{{ item.interface }}"

    # Optional JSON output for integrations:
    # - name: Raw JSON result
    #   debug:
    #     var: interfaces_info

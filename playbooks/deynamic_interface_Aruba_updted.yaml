################################################################################
# README (Tiny)
# ------------------------------------------------------------------------------
# Purpose
#   Automate ArubaOS-Switch access port configuration based on room/port and
#   device types, supporting four cases:
#     1) PHONE ONLY                 -> tagged phone VLAN + port-security(1)
#     2) DEVICE ONLY (non-phone)    -> untagged device VLAN + port-security(1)
#     3) DEVICE + PHONE             -> untagged device VLAN + tagged phone VLAN
#                                      + port-security(2)
#     4) NONE (admin down)          -> disable + name suffix "_disable"
#
# Inputs (typical -e extra-vars)
#   room: "4211"
#   port_number: "2/9"                          # wall point or direct port
#   device_type: "pc"|"printer"|"camera"|"phone"|"none"
#   second_device_type: "phone"|"none"
#   device_name: "TeacherPC"                    # optional friendly label
#   second_device_name: "DeskPhone"             # optional friendly label
#
# Required vars files (relative paths)
#   ../vars/switch_mapping.yml      # { switch_name: [rooms...] }
#   ../vars/interface_name.yml      # { interface_descriptions: {room: "Label"} }
#   ../vars/vlan_mapping.yml        # { pc: 10, printer: 20, camera: 30, phone: 40, ... }
#   ../vars/wall_point_mapping.yml  # { "WP-2/9": "2/9", ... } or direct passthrough
#
# Example invocations
#   # PHONE ONLY (phone+none, phone+phone, or none+phone)
#   ansible-playbook playbooks/port_config.yml -e room=4211 -e port_number=2/9 \
#     -e device_type=phone -e second_device_type=none
#
#   # DEVICE ONLY (PC on data VLAN)
#   ansible-playbook playbooks/port_config.yml -e room=4211 -e port_number=2/9 \
#     -e device_type=pc -e second_device_type=none
#
#   # DEVICE + PHONE (PC + IP phone)
#   ansible-playbook playbooks/port_config.yml -e room=4211 -e port_number=2/9 \
#     -e device_type=pc -e second_device_type=phone
#
#   # NONE (admin down)
#   ansible-playbook playbooks/port_config.yml -e room=4211 -e port_number=2/9 \
#     -e device_type=none -e second_device_type=none
#
# Notes
#   - Port-security uses the 2-line form requested:
#       no port-security <PORT>
#       port-security <PORT> learn-mode static address-limit <N> action send-disable
#     With N = 1 (single endpoint) or N = 2 (device + phone).
#   - cleanup_strategy=wipe resets VLAN membership before applying desired state.
################################################################################


# ==============================================================================
# Play 1: Resolve target switch & port + build final interface name
#   - Discover switch by room membership
#   - Normalize wall point label to actual port
#   - Create a clean interface description with optional device suffixes
#   - Add a dynamic host to the inventory for Play 2 to configure
# ==============================================================================
- name: Resolve Switch Based on Room Number and Convert Wall Point
  hosts: localhost
  gather_facts: false
  vars_files:
    - ../vars/switch_mapping.yml
    - ../vars/interface_name.yml
    - ../vars/vlan_mapping.yml
    - ../vars/wall_point_mapping.yml

  tasks:
    # Identify the switch that owns this room via switch_mapping (switch -> [rooms])
    - name: Find Switch for Given Room
      set_fact:
        switch_name: "{{ item.key }}"
      loop: "{{ switch_mapping | dict2items }}"
      when:
        - room is defined
        - room | length > 0
        - (room | lower) in (item.value | map('lower') | list)

    # Fail fast if room is not mapped to any switch
    - name: Fail if No Matching Switch is Found
      fail:
        msg: "No switch found for room {{ room }}. Check switch_mapping.yml"
      when: switch_name is not defined

    # If port_number is a wall-point label and exists in mapping, translate it
    - name: Convert wall point label to actual switch port (if mapping exists)
      set_fact:
        actual_port_number: "{{ wall_point_mapping[port_number] }}"
      when:
        - port_number is defined
        - port_number in wall_point_mapping

    # Otherwise, treat port_number as the literal switch port
    - name: Use direct port number if not in wall point mapping
      set_fact:
        actual_port_number: "{{ port_number }}"
      when:
        - port_number is defined
        - port_number not in wall_point_mapping

    # Ensure we have a valid target port for Play 2
    - name: Fail if Port Number Not Provided
      fail:
        msg: "Port number is required"
      when: actual_port_number is not defined or (actual_port_number | string) == ""

    # Build a base, human-friendly interface label (with room-aware fallback)
    - name: Compute base interface label
      set_fact:
        interface_base_label: >-
          {{
            interface_descriptions.get(
              room,
              'Port_' ~ (room | string) ~ '_WP' ~ (port_number | string)
            )
            if room is defined and room is not none and (room | string) | length > 0
            else 'Port_WP' ~ (port_number | string)
          }}

    # Prefer friendly device_name(s) if provided; fall back to device_type(s)
    - name: Build device labels
      set_fact:
        device_label_1: "{{ (device_name | default(device_type | default('')) | string) | trim | lower }}"
        device_label_2: "{{ (second_device_name | default(second_device_type | default('')) | string) | trim | lower }}"

    # Build suffix list (filter out empty/none)
    - name: Build device label suffix list
      set_fact:
        device_suffix_list: >-
          {{
            ([device_label_1] if device_label_1 not in ['','none'] else [])
            + ([device_label_2] if device_label_2 not in ['','none'] else [])
          }}

    # Compose final interface description (base + optional suffixes)
    - name: Build final interface description with device suffixes
      set_fact:
        interface_description_final: >-
          {{
            interface_base_label
          }}{{ '_' ~ (device_suffix_list | join('_')) if (device_suffix_list | length) > 0 else '' }}

    # Add a dynamic host with all variables Play 2 needs
    - name: Add Resolved Switch to Inventory
      add_host:
        name: "{{ switch_name }}"
        groups: dynamic_switches
        ansible_port_number: "{{ actual_port_number }}"
        interface_description: "{{ interface_description_final }}"
        ansible_device_type: "{{ device_type | default('none') }}"
        ansible_second_device_type: "{{ second_device_type | default('none') }}"
        # ansible_host: "{{ switch_ip_mapping[switch_name] }}"  # optional mgmt IP mapping


# ==============================================================================
# Play 2: Configure the ArubaOS-Switch interface
#   - Read current config & compute differences (safe reconciliation)
#   - Apply one of four cases (phone-only, device-only, device+phone, none)
#   - Persist configuration
# ==============================================================================
- name: Configure Aruba Switch Port Based on Device Type and Configuration Cases
  hosts: dynamic_switches
  gather_facts: false
  connection: network_cli
  vars:
    ansible_network_os: community.network.aruba
    cleanup_strategy: wipe        # wipe | safe (wipe = remove all VLANs before apply)
  collections:
    - community.network
  vars_files:
    - ../vars/vlan_mapping.yml

  tasks:
    # Quick visibility of what will be configured on which port
    - name: Debug (switch/port/input)
      debug:
        msg:
          - "Switch: {{ inventory_hostname }}"
          - "Port: {{ ansible_port_number }}"
          - "Interface Final Description: {{ interface_description }}"
          - "Primary Device Type: {{ ansible_device_type }}"
          - "Second Device Type: {{ ansible_second_device_type }}"

    # Compute normalized booleans for clear, correct branching
    - name: Compute mode flags
      set_fact:
        is_phone_only: >-
          {{
            (ansible_device_type == 'phone' and ansible_second_device_type in ['none','phone'])
            or
            (ansible_device_type == 'none' and ansible_second_device_type == 'phone')
          }}
        is_device_only: >-
          {{
            (ansible_device_type not in ['phone','none'])
            and (ansible_second_device_type == 'none')
          }}
        is_device_plus_phone: >-
          {{
            (ansible_device_type not in ['phone','none'])
            and (ansible_second_device_type == 'phone')
          }}
        is_disabled: >-
          {{
            (ansible_device_type == 'none')
            and (ansible_second_device_type == 'none')
          }}

    ############################################################################
    # CASE 1: PHONE ONLY
    #   Triggers for this case:
    #     - device_type=phone & second_device_type in [none, phone]
    #     - device_type=none  & second_device_type=phone
    #   Desired state:
    #     - VLANs: tagged phone VLAN only
    #     - Port security: limit 1 (2-line form)
    ############################################################################
    - name: CASE 1 | Read current interface config
      community.network.aruba_command:
        commands:
          - "show running-config interface {{ ansible_port_number }}"
      register: c1_iface_cmd
      when: is_phone_only | bool

    - name: CASE 1 | Extract interface text
      set_fact:
        c1_text: "{{ (c1_iface_cmd.stdout[0] | default('')) | lower }}"
      when: is_phone_only | bool

    - name: CASE 1 | Parse existing VLAN membership
      set_fact:
        c1_old_untagged: "{{ c1_text | regex_findall('untagged\\s+vlan\\s+(\\d+)') | unique }}"
        c1_old_tagged:   "{{ c1_text | regex_findall('tagged\\s+vlan\\s+(\\d+)') | unique }}"
        c1_desired_untagged: []
        c1_desired_tagged: ["{{ vlan_mapping.phone | string }}"]
      when: is_phone_only | bool

    - name: CASE 1 | Compute removal lists
      set_fact:
        c1_remove_untagged: >-
          {{ c1_old_untagged
             if cleanup_strategy == 'wipe'
             else (c1_old_untagged | map('string') | list) | difference(c1_desired_untagged) }}
        c1_remove_tagged: >-
          {{ c1_old_tagged
             if cleanup_strategy == 'wipe'
             else (c1_old_tagged | map('string') | list) | difference(c1_desired_tagged) }}
      when: is_phone_only | bool

    - name: CASE 1 | Remove old UNTAGGED VLAN(s)
      community.network.aruba_config:
        parents: "interface {{ ansible_port_number }}"
        lines:
          - "no untagged vlan {{ item }}"
      loop: "{{ c1_remove_untagged | default([]) }}"
      when:
        - is_phone_only | bool
        - (c1_remove_untagged | default([])) | length > 0

    - name: CASE 1 | Remove old TAGGED VLAN(s)
      community.network.aruba_config:
        parents: "interface {{ ansible_port_number }}"
        lines:
          - "no tagged vlan {{ item }}"
      loop: "{{ c1_remove_tagged | default([]) }}"
      when:
        - is_phone_only | bool
        - (c1_remove_tagged | default([])) | length > 0

    - name: CASE 1 | Apply phone-only interface config
      community.network.aruba_config:
        parents: "interface {{ ansible_port_number }}"
        lines:
          - "name {{ interface_description | quote }}"
          - "tagged vlan {{ vlan_mapping.phone }}"
          - "speed-duplex auto"
          - "enable"
      when: is_phone_only | bool

    - name: CASE 1 | Port security (2-line form, limit 1)
      community.network.aruba_config:
        lines:
          - "no port-security {{ ansible_port_number }}"
          - "port-security {{ ansible_port_number }} learn-mode static address-limit 1 action send-disable"
      when: is_phone_only | bool

    ############################################################################
    # CASE 2: NON-PHONE DEVICE ONLY
    #   Trigger: device_type != phone|none AND second_device_type == none
    #   Desired state:
    #     - VLANs: untagged device VLAN
    #     - Port security: limit 1 (2-line form)
    ############################################################################
    - name: CASE 2 | Read current interface config
      community.network.aruba_command:
        commands:
          - "show running-config interface {{ ansible_port_number }}"
      register: c2_iface_cmd
      when: is_device_only | bool

    - name: CASE 2 | Extract interface text
      set_fact:
        c2_text: "{{ (c2_iface_cmd.stdout[0] | default('')) | lower }}"
      when: is_device_only | bool

    - name: CASE 2 | Parse existing VLAN membership
      set_fact:
        c2_old_untagged: "{{ c2_text | regex_findall('untagged\\s+vlan\\s+(\\d+)') | unique }}"
        c2_old_tagged:   "{{ c2_text | regex_findall('tagged\\s+vlan\\s+(\\d+)') | unique }}"
        c2_desired_untagged: ["{{ vlan_mapping[ansible_device_type] | string }}"]
        c2_desired_tagged: []
      when: is_device_only | bool

    - name: CASE 2 | Compute removal lists
      set_fact:
        c2_remove_untagged: >-
          {{ c2_old_untagged
             if cleanup_strategy == 'wipe'
             else (c2_old_untagged | map('string') | list) | difference(c2_desired_untagged) }}
        c2_remove_tagged: >-
          {{ c2_old_tagged
             if cleanup_strategy == 'wipe'
             else (c2_old_tagged | map('string') | list) | difference(c2_desired_tagged) }}
      when: is_device_only | bool

    - name: CASE 2 | Remove old UNTAGGED VLAN(s)
      community.network.aruba_config:
        parents: "interface {{ ansible_port_number }}"
        lines:
          - "no untagged vlan {{ item }}"
      loop: "{{ c2_remove_untagged | default([]) }}"
      when:
        - is_device_only | bool
        - (c2_remove_untagged | default([])) | length > 0

    - name: CASE 2 | Remove old TAGGED VLAN(s)
      community.network.aruba_config:
        parents: "interface {{ ansible_port_number }}"
        lines:
          - "no tagged vlan {{ item }}"
      loop: "{{ c2_remove_tagged | default([]) }}"
      when:
        - is_device_only | bool
        - (c2_remove_tagged | default([])) | length > 0

    - name: CASE 2 | Apply non-phone interface config
      community.network.aruba_config:
        parents: "interface {{ ansible_port_number }}"
        lines:
          - "name {{ interface_description | quote }}"
          - "untagged vlan {{ vlan_mapping[ansible_device_type] }}"
          - "speed-duplex auto"
          - "enable"
      when: is_device_only | bool

    - name: CASE 2 | Port security (2-line form, limit 1)
      community.network.aruba_config:
        lines:
          - "no port-security {{ ansible_port_number }}"
          - "port-security {{ ansible_port_number }} learn-mode static address-limit 1 action send-disable"
      when: is_device_only | bool

    ############################################################################
    # CASE 3: DEVICE + PHONE
    #   Trigger: device_type != phone|none AND second_device_type == phone
    #   Desired state:
    #     - VLANs: untagged device VLAN + tagged phone VLAN
    #     - Port security: limit 2 (2-line form)
    ############################################################################
    - name: CASE 3 | Device with phone | Apply config
      when: is_device_plus_phone | bool
      block:
        - name: CASE 3 | Apply interface config
          community.network.aruba_config:
            parents: "interface {{ ansible_port_number }}"
            lines:
              - "name {{ interface_description | quote }}"
              - "untagged vlan {{ vlan_mapping[ansible_device_type] }}"
              - "tagged vlan {{ vlan_mapping.phone }}"
              - "speed-duplex auto"
              - "enable"

        - name: CASE 3 | Port security (2-line form, limit 2)
          community.network.aruba_config:
            lines:
              - "no port-security {{ ansible_port_number }}"
              - "port-security {{ ansible_port_number }} learn-mode static address-limit 2 action send-disable"

    ############################################################################
    # CASE 4: NONE (ADMIN DOWN)
    #   Trigger: device_type == none AND second_device_type == none
    #   Desired state:
    #     - Port disabled
    #     - Name annotated with "_disable" (idempotent)
    #     - Port security: limit 1 (2-line form)
    ############################################################################
    - name: CASE 4 | None device | Apply config
      when: is_disabled | bool
      block:
        - name: CASE 4 | Apply interface config (with _disable suffix)
          community.network.aruba_config:
            parents: "interface {{ ansible_port_number }}"
            lines:
              - >-
                name {{
                  (
                    interface_description
                    if (interface_description is search('(_disable)$'))
                    else (interface_description ~ '_disable')
                  ) | quote
                }}
              - "speed-duplex auto"
              - "disable"

        - name: CASE 4 | Port security (2-line form, limit 1)
          community.network.aruba_config:
            lines:
              - "no port-security {{ ansible_port_number }}"
              - "port-security {{ ansible_port_number }} learn-mode static address-limit 1 action send-disable"

    # Persist configuration to startup
    - name: Save configuration
      community.network.aruba_command:
        commands:
          - "write memory"

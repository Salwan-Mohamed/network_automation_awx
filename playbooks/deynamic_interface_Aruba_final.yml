---
################################################################################
# PLAYBOOK: dynamic_interface.yml  (ArubaOS-Switch, AOS-S)
#
# PURPOSE
# - Resolve a switch and physical port from a room + wall point label.
# - Configure that interface based on the device type(s) for four cases:
#     Case 1 : Phone only                 → tagged phone VLAN
#     Case 2 : Non-phone only             → untagged device VLAN
#     Case 3 : Non-phone + Phone on port  → untagged device + tagged phone VLAN
#     Case 4 : None (port disabled)       → admin down
#
# HIGHLIGHTS
# - Actively **cleans old VLAN membership** in Case 1 & 2:
#   * Strategy A (wipe): remove all existing un/tagged VLANs first
#   * Strategy B (safe): remove only VLANs not in the desired state
# - Quotes interface "name" (description) to handle spaces safely.
# - Runs **port-security in GLOBAL (parent) config**, not under interface.
# - Uses AOS-S specific modules:
#     community.network.aruba_config / aruba_command
#   (These handle CLI context and sub-modes reliably on AOS-S hardware.)
#
# INPUTS (pass via AWX Extra Vars, Survey, or CLI -e):
#   room: "n-g-36"            # must match a key in switch_mapping.yml values
#   port_number: "2/2"        # exact front-panel label or stack/slot/port string
#   device_type: "pc"         # e.g. pc | printer | ap | phone | none
#   second_device_type: "none"  # e.g. phone | none
#
# DEPENDENCY VAR FILES (relative to this playbook):
#   ../vars/switch_mapping.yml       # mapping: switch_name → [rooms...]
#   ../vars/interface_name.yml       # mapping: room → interface description
#   ../vars/vlan_mapping.yml         # mapping: device_type → VLAN ID; plus "phone"
#   ../vars/wall_point_mapping.yml   # mapping: wall point label → actual port
#
# INVENTORY
# - Ensure each switch_name (e.g., aruba_N11) exists in inventory with ansible_host.
# - If not, you can inject ansible_host via add_host (see commented hint below).
################################################################################


################################################################################
# PLAY 1: Resolve target switch & physical port
################################################################################
- name: Resolve Switch Based on Room Number and Convert Wall Point
  hosts: localhost
  gather_facts: false
  vars_files:
    - ../vars/switch_mapping.yml
    - ../vars/interface_name.yml
    - ../vars/vlan_mapping.yml
    - ../vars/wall_point_mapping.yml

  tasks:
    # Find which switch contains the given room. We loop over mapping items and
    # pick the one whose value-list (rooms) contains the provided room (case-insensitive).
    - name: Find Switch for Given Room
      set_fact:
        switch_name: "{{ item.key }}"
      loop: "{{ switch_mapping | dict2items }}"
      when:
        - room is defined
        - room | length > 0
        - (room | lower) in (item.value | map('lower') | list)

    # If no switch matched, fail early with a helpful message.
    - name: Fail if No Matching Switch is Found
      fail:
        msg: "No switch found for room {{ room }}. Check switch_mapping.yml"
      when: switch_name is not defined

    # A wall point label (e.g., "WP2B") might map to a real port id ("2/2").
    # If mapping present, translate it; otherwise we’ll use the provided port_number directly.
    - name: Convert wall point label to actual switch port (if mapping exists)
      set_fact:
        actual_port_number: "{{ wall_point_mapping[port_number] }}"
      when:
        - port_number is defined
        - port_number in wall_point_mapping

    - name: Use direct port number if not in wall point mapping
      set_fact:
        actual_port_number: "{{ port_number }}"
      when:
        - port_number is defined
        - port_number not in wall_point_mapping

    # Make sure we have a port to work with.
    - name: Fail if Port Number Not Provided
      fail:
        msg: "Port number is required"
      when: actual_port_number is not defined or (actual_port_number | string) == ""

    # Build a human-friendly interface description.
    # 1) Prefer a predefined name from interface_name.yml keyed by room.
    # 2) Otherwise, fallback to a generic pattern including room & wall point.
    - name: Get Interface Description (from table, else fallback)
      set_fact:
        interface_description: >-
          {{
            interface_descriptions.get(
              room,
              'Port_' ~ (room | string) ~ '_WP' ~ (port_number | string)
            )
            if room is defined and room is not none and (room | string) | length > 0
            else 'Port_WP' ~ (port_number | string)
          }}

    # Dynamically add the resolved switch as a host for Play 2 with facts we need.
    # NOTE: If your inventory doesn't have "switch_name" with an ansible_host/IP,
    # you can also add "ansible_host: {{ switch_ip_mapping[switch_name] }}" here.
    - name: Add Resolved Switch to Inventory
      add_host:
        name: "{{ switch_name }}"
        groups: dynamic_switches
        ansible_port_number: "{{ actual_port_number }}"
        interface_description: "{{ interface_description }}"
        ansible_device_type: "{{ device_type | default('none') }}"
        ansible_second_device_type: "{{ second_device_type | default('none') }}"


################################################################################
# PLAY 2: Connect to the switch and configure the interface
################################################################################
- name: Configure Aruba Switch Port Based on Device Type and Configuration Cases
  hosts: dynamic_switches
  gather_facts: false

  # ArubaOS-Switch over SSH / CLI
  connection: network_cli

  # This ensures the correct Aruba AOS-S driver handles CLI context transitions.
  vars:
    ansible_network_os: community.network.aruba

    # VLAN cleanup strategy for Case 1 & 2:
    #   wipe : remove all existing un/tagged VLANs on the port, then apply desired
    #   safe : remove only VLANs not in desired state (keeps already-desired VLANs)
    cleanup_strategy: wipe     # change to "safe" if you prefer selective cleanup

  # We deliberately use the Aruba collection because it is the most reliable way
  # to manage AOS-S interface sub-modes without parser slips.
  collections:
    - community.network

  vars_files:
    - ../vars/vlan_mapping.yml

  tasks:
    # ────────────────────────────────────────────────────────────────────────
    # CASE 1: Phone only  → tagged phone VLAN
    # ────────────────────────────────────────────────────────────────────────

    # Grab the current running-config for the target interface.
    - name: CASE 1 | Read current interface config
      community.network.aruba_command:
        commands:
          - "show running-config interface {{ ansible_port_number }}"
      register: c1_iface_cmd
      when: ansible_device_type == "phone"

    # Plain text of the interface section (lowercased for easy regex).
    - name: CASE 1 | Extract interface text
      set_fact:
        c1_text: "{{ (c1_iface_cmd.stdout[0] | default('')) | lower }}"
      when: ansible_device_type == "phone"

    # Parse any existing untagged / tagged VLAN IDs so we can remove old state.
    - name: CASE 1 | Parse existing VLAN membership
      set_fact:
        c1_old_untagged: "{{ c1_text | regex_findall('untagged\\s+vlan\\s+(\\d+)') | unique }}"
        c1_old_tagged:   "{{ c1_text | regex_findall('tagged\\s+vlan\\s+(\\d+)') | unique }}"
        c1_desired_untagged: []                               # phone-only has no untagged
        c1_desired_tagged: ["{{ vlan_mapping.phone | string }}"]  # phone VLAN tagged
      when: ansible_device_type == "phone"

    # Build the removal lists according to the chosen cleanup strategy (wipe/safe).
    - name: CASE 1 | Compute removal lists
      set_fact:
        c1_remove_untagged: >-
          {{ c1_old_untagged
             if cleanup_strategy == 'wipe'
             else (c1_old_untagged | map('string') | list) | difference(c1_desired_untagged) }}
        c1_remove_tagged: >-
          {{ c1_old_tagged
             if cleanup_strategy == 'wipe'
             else (c1_old_tagged | map('string') | list) | difference(c1_desired_tagged) }}
      when: ansible_device_type == "phone"

    # Remove leftover UNTAGGED VLANs (if any) in proper interface context.
    - name: CASE 1 | Remove old UNTAGGED VLAN(s)
      community.network.aruba_config:
        parents: "interface {{ ansible_port_number }}"
        lines:
          - "no untagged vlan {{ item }}"
      loop: "{{ c1_remove_untagged | default([]) }}"
      when:
        - ansible_device_type == "phone"
        - (c1_remove_untagged | default([])) | length > 0

    # Remove leftover TAGGED VLANs (if any) in proper interface context.
    - name: CASE 1 | Remove old TAGGED VLAN(s)
      community.network.aruba_config:
        parents: "interface {{ ansible_port_number }}"
        lines:
          - "no tagged vlan {{ item }}"
      loop: "{{ c1_remove_tagged | default([]) }}"
      when:
        - ansible_device_type == "phone"
        - (c1_remove_tagged | default([])) | length > 0

    # Apply the phone-only config: quoted name, add tagged phone VLAN, enable.
    - name: CASE 1 | Apply phone-only interface config
      community.network.aruba_config:
        parents: "interface {{ ansible_port_number }}"
        lines:
          - "name {{ interface_description | quote }}"
          - "tagged vlan {{ vlan_mapping.phone }}"
          - "speed-duplex auto"
          - "enable"
      when: ansible_device_type == "phone"

    # Apply port-security in GLOBAL (parent) configuration mode for this port.
    - name: CASE 1 | Port security (GLOBAL/parent)
      community.network.aruba_config:
        lines:
          - "port-security {{ ansible_port_number }} learn-mode static"
          - "port-security {{ ansible_port_number }} address-limit 1"
          - "port-security {{ ansible_port_number }} action send-disable"
      when: ansible_device_type == "phone"


    # ────────────────────────────────────────────────────────────────────────
    # CASE 2: Non-phone only  → untagged device VLAN
    # ────────────────────────────────────────────────────────────────────────

    - name: CASE 2 | Read current interface config
      community.network.aruba_command:
        commands:
          - "show running-config interface {{ ansible_port_number }}"
      register: c2_iface_cmd
      when:
        - ansible_device_type != "phone"
        - ansible_device_type != "none"
        - ansible_second_device_type == "none"

    - name: CASE 2 | Extract interface text
      set_fact:
        c2_text: "{{ (c2_iface_cmd.stdout[0] | default('')) | lower }}"
      when:
        - ansible_device_type != "phone"
        - ansible_device_type != "none"
        - ansible_second_device_type == "none"

    - name: CASE 2 | Parse existing VLAN membership
      set_fact:
        c2_old_untagged: "{{ c2_text | regex_findall('untagged\\s+vlan\\s+(\\d+)') | unique }}"
        c2_old_tagged:   "{{ c2_text | regex_findall('tagged\\s+vlan\\s+(\\d+)') | unique }}"
        c2_desired_untagged: ["{{ vlan_mapping[ansible_device_type] | string }}"]
        c2_desired_tagged: []
      when:
        - ansible_device_type != "phone"
        - ansible_device_type != "none"
        - ansible_second_device_type == "none"

    - name: CASE 2 | Compute removal lists
      set_fact:
        c2_remove_untagged: >-
          {{ c2_old_untagged
             if cleanup_strategy == 'wipe'
             else (c2_old_untagged | map('string') | list) | difference(c2_desired_untagged) }}
        c2_remove_tagged: >-
          {{ c2_old_tagged
             if cleanup_strategy == 'wipe'
             else (c2_old_tagged | map('string') | list) | difference(c2_desired_tagged) }}
      when:
        - ansible_device_type != "phone"
        - ansible_device_type != "none"
        - ansible_second_device_type == "none"

    - name: CASE 2 | Remove old UNTAGGED VLAN(s)
      community.network.aruba_config:
        parents: "interface {{ ansible_port_number }}"
        lines:
          - "no untagged vlan {{ item }}"
      loop: "{{ c2_remove_untagged | default([]) }}"
      when:
        - (c2_remove_untagged | default([])) | length > 0
        - ansible_device_type != "phone"
        - ansible_device_type != "none"
        - ansible_second_device_type == "none"

    - name: CASE 2 | Remove old TAGGED VLAN(s)
      community.network.aruba_config:
        parents: "interface {{ ansible_port_number }}"
        lines:
          - "no tagged vlan {{ item }}"
      loop: "{{ c2_remove_tagged | default([]) }}"
      when:
        - (c2_remove_tagged | default([])) | length > 0
        - ansible_device_type != "phone"
        - ansible_device_type != "none"
        - ansible_second_device_type == "none"

    # Apply the non-phone config: quoted name, set untagged device VLAN, enable.
    - name: CASE 2 | Apply non-phone interface config
      community.network.aruba_config:
        parents: "interface {{ ansible_port_number }}"
        lines:
          - "name {{ interface_description | quote }}"
          - "untagged vlan {{ vlan_mapping[ansible_device_type] }}"
          - "speed-duplex auto"
          - "enable"
      when:
        - ansible_device_type != "phone"
        - ansible_device_type != "none"
        - ansible_second_device_type == "none"

    - name: CASE 2 | Port security (GLOBAL/parent)
      community.network.aruba_config:
        lines:
          - "port-security {{ ansible_port_number }} learn-mode static"
          - "port-security {{ ansible_port_number }} address-limit 1"
          - "port-security {{ ansible_port_number }} action send-disable"
      when:
        - ansible_device_type != "phone"
        - ansible_device_type != "none"
        - ansible_second_device_type == "none"


    # ────────────────────────────────────────────────────────────────────────
    # CASE 3: Non-phone + Phone on same port
    #         → untagged device VLAN + tagged phone VLAN
    # ────────────────────────────────────────────────────────────────────────
    - name: CASE 3 | Device with phone | Apply config
      when: ansible_second_device_type == "phone"
      block:
        - name: CASE 3 | Apply interface config
          community.network.aruba_config:
            parents: "interface {{ ansible_port_number }}"
            lines:
              - "name {{ interface_description | quote }}"
              - "untagged vlan {{ vlan_mapping[ansible_device_type] }}"
              - "tagged vlan {{ vlan_mapping.phone }}"
              - "speed-duplex auto"
              - "enable"

        # Allow two MACs (device + phone) at global port-security.
        - name: CASE 3 | Port security (GLOBAL/parent; allow 2)
          community.network.aruba_config:
            lines:
              - "port-security {{ ansible_port_number }} learn-mode static"
              - "port-security {{ ansible_port_number }} address-limit 2"
              - "port-security {{ ansible_port_number }} action send-disable"


    # ────────────────────────────────────────────────────────────────────────
    # CASE 4: None → port disabled, description kept
    # ────────────────────────────────────────────────────────────────────────
    - name: CASE 4 | None device | Apply config
      when:
        - ansible_device_type == "none"
        - ansible_second_device_type == "none"
      block:
        - name: CASE 4 | Apply interface config
          community.network.aruba_config:
            parents: "interface {{ ansible_port_number }}"
            lines:
              - "name {{ interface_description | quote }}"
              - "speed-duplex auto"
              - "disable"

        - name: CASE 4 | Port security (GLOBAL/parent; keep 1)
          community.network.aruba_config:
            lines:
              - "port-security {{ ansible_port_number }} learn-mode static"
              - "port-security {{ ansible_port_number }} address-limit 1"
              - "port-security {{ ansible_port_number }} action send-disable"


    # Persist the changes.
    - name: Save configuration
      community.network.aruba_command:
        commands:
          - "write memory"
